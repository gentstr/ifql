// Code generated by collistallocator.gen.go.tmpl.
// DO NOT EDIT.

package execute

import (
	"reflect"
	"unsafe"
)

func (a *ColListAllocator) FreeBools(b []bool) {
	a.free(a.castBoolsToBytes(b))
}

func (a *ColListAllocator) FreeInts(b []int64) {
	a.free(a.castIntsToBytes(b))
}

func (a *ColListAllocator) FreeUInts(b []uint64) {
	a.free(a.castUIntsToBytes(b))
}

func (a *ColListAllocator) FreeFloats(b []float64) {
	a.free(a.castFloatsToBytes(b))
}

func (a *ColListAllocator) FreeStrings(b []string) {
	a.free(a.castStringsToBytes(b))
}

func (a *ColListAllocator) FreeTimes(b []Time) {
	a.free(a.castTimesToBytes(b))
}

// Bools makes a slice of bool values.
func (a *ColListAllocator) Bools(l, c int) []bool {
	return a.castBytesToBools(a.alloc.Allocate(c * boolSize))
}

// AppendBools appends vs to the slice
func (a *ColListAllocator) AppendBools(slice []bool, vs ...bool) []bool {
	oldLen := len(slice)
	newLen := oldLen + len(vs)
	if newLen < cap(slice) {
		return append(slice, vs...)
	}
	slice = a.castBytesToBools(a.reallocate(newLen*boolSize, a.castBoolsToBytes(slice)))
	slice = append(slice[:oldLen], vs...)
	return slice
}

func (a *ColListAllocator) castBytesToBools(b []byte) []bool {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []bool
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / boolSize
	s.Cap = h.Cap / boolSize

	return res
}

func (a *ColListAllocator) castBoolsToBytes(b []bool) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * boolSize
	s.Cap = h.Cap * boolSize

	return res
}

// Ints makes a slice of int64 values.
func (a *ColListAllocator) Ints(l, c int) []int64 {
	return a.castBytesToInts(a.alloc.Allocate(c * int64Size))
}

// AppendInts appends vs to the slice
func (a *ColListAllocator) AppendInts(slice []int64, vs ...int64) []int64 {
	oldLen := len(slice)
	newLen := oldLen + len(vs)
	if newLen < cap(slice) {
		return append(slice, vs...)
	}
	slice = a.castBytesToInts(a.reallocate(newLen*int64Size, a.castIntsToBytes(slice)))
	slice = append(slice[:oldLen], vs...)
	return slice
}

func (a *ColListAllocator) castBytesToInts(b []byte) []int64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []int64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / int64Size
	s.Cap = h.Cap / int64Size

	return res
}

func (a *ColListAllocator) castIntsToBytes(b []int64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * int64Size
	s.Cap = h.Cap * int64Size

	return res
}

// UInts makes a slice of uint64 values.
func (a *ColListAllocator) UInts(l, c int) []uint64 {
	return a.castBytesToUInts(a.alloc.Allocate(c * uint64Size))
}

// AppendUInts appends vs to the slice
func (a *ColListAllocator) AppendUInts(slice []uint64, vs ...uint64) []uint64 {
	oldLen := len(slice)
	newLen := oldLen + len(vs)
	if newLen < cap(slice) {
		return append(slice, vs...)
	}
	slice = a.castBytesToUInts(a.reallocate(newLen*uint64Size, a.castUIntsToBytes(slice)))
	slice = append(slice[:oldLen], vs...)
	return slice
}

func (a *ColListAllocator) castBytesToUInts(b []byte) []uint64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []uint64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / uint64Size
	s.Cap = h.Cap / uint64Size

	return res
}

func (a *ColListAllocator) castUIntsToBytes(b []uint64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * uint64Size
	s.Cap = h.Cap * uint64Size

	return res
}

// Floats makes a slice of float64 values.
func (a *ColListAllocator) Floats(l, c int) []float64 {
	return a.castBytesToFloats(a.alloc.Allocate(c * float64Size))
}

// AppendFloats appends vs to the slice
func (a *ColListAllocator) AppendFloats(slice []float64, vs ...float64) []float64 {
	oldLen := len(slice)
	newLen := oldLen + len(vs)
	if newLen < cap(slice) {
		return append(slice, vs...)
	}
	slice = a.castBytesToFloats(a.reallocate(newLen*float64Size, a.castFloatsToBytes(slice)))
	slice = append(slice[:oldLen], vs...)
	return slice
}

func (a *ColListAllocator) castBytesToFloats(b []byte) []float64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []float64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / float64Size
	s.Cap = h.Cap / float64Size

	return res
}

func (a *ColListAllocator) castFloatsToBytes(b []float64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * float64Size
	s.Cap = h.Cap * float64Size

	return res
}

// Strings makes a slice of string values.
func (a *ColListAllocator) Strings(l, c int) []string {
	return a.castBytesToStrings(a.alloc.Allocate(c * stringSize))
}

// AppendStrings appends vs to the slice
func (a *ColListAllocator) AppendStrings(slice []string, vs ...string) []string {
	oldLen := len(slice)
	newLen := oldLen + len(vs)
	if newLen < cap(slice) {
		return append(slice, vs...)
	}
	slice = a.castBytesToStrings(a.reallocate(newLen*stringSize, a.castStringsToBytes(slice)))
	slice = append(slice[:oldLen], vs...)
	return slice
}

func (a *ColListAllocator) castBytesToStrings(b []byte) []string {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []string
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / stringSize
	s.Cap = h.Cap / stringSize

	return res
}

func (a *ColListAllocator) castStringsToBytes(b []string) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * stringSize
	s.Cap = h.Cap * stringSize

	return res
}

// Times makes a slice of Time values.
func (a *ColListAllocator) Times(l, c int) []Time {
	return a.castBytesToTimes(a.alloc.Allocate(c * timeSize))
}

// AppendTimes appends vs to the slice
func (a *ColListAllocator) AppendTimes(slice []Time, vs ...Time) []Time {
	oldLen := len(slice)
	newLen := oldLen + len(vs)
	if newLen < cap(slice) {
		return append(slice, vs...)
	}
	slice = a.castBytesToTimes(a.reallocate(newLen*timeSize, a.castTimesToBytes(slice)))
	slice = append(slice[:oldLen], vs...)
	return slice
}

func (a *ColListAllocator) castBytesToTimes(b []byte) []Time {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []Time
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / timeSize
	s.Cap = h.Cap / timeSize

	return res
}

func (a *ColListAllocator) castTimesToBytes(b []Time) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * timeSize
	s.Cap = h.Cap * timeSize

	return res
}
