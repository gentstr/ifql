{
package ifql

}

Start
  = __ program:Program __ {
      return program, nil
    }

Program
  = body:SourceElements {
      return program(body, c.text, c.pos)
    }

SourceElements
  = head:SourceElement tail:(__ SourceElement)* {
      return srcElems(head, tail)
    }

SourceElement
  = Statement

Statement
  = varstmt:VariableStatement
  / exprstmt:ExpressionStatement

VariableStatement
  = VarToken __ declaration:VariableDeclaration {
      return varstmt(declaration, c.text, c.pos)
    }

VarToken = "var"

VariableDeclaration
  = id:Identifier __ initExpr:Initializer {
      return vardecl(id, initExpr, c.text, c.pos)
    }

Initializer
  = "=" !"=" __ expression:VariableExpression {
      return expression, nil
    }

// TODO: Perhaps this should be modeled like an AssignmentExpresssion
VariableExpression
  = CallExpression
  / Primary

ExpressionStatement
  = call:CallExpression {
        return exprstmt(call, c.text, c.pos)
    }

MemberExpression
  = head:Identifier // TODO: should be primary
    tail:(
        __ "." __ property:Identifier {
          return property, nil
        }
    )*
    {
      return memberexprs(head, tail, c.text, c.pos)
    }

CallExpression
  = head:(
      callee:MemberExpression __ args:Arguments {
        return callexpr(callee, args, c.text, c.pos)
      }
    )
    tail:(
        __ args:Arguments {
          return callexpr(nil, args, c.text, c.pos)
        }
      / __ "." __ property:Identifier {
          return memberexpr(nil, property, c.text, c.pos)
        }
    )*
    {
      return callexprs(head, tail, c.text, c.pos)
    }

Arguments
  = "(" __ args:(FunctionArgs)? __ ")" {
      return args, nil
    }

FunctionArgs
  = first:FunctionArg __ rest:FunctionArgsRest* {
      return object(first, rest, c.text, c.pos)
    }

FunctionArgsRest
  = "," __  arg:FunctionArg {
      return arg, nil
    }

FunctionArg
  = key:Identifier __  ":" __ value:FunctionArgValues {
      return property(key, value, c.text, c.pos)
    }

FunctionArgValues
  = WhereExpr
  / Primary

WhereExpr
  = "{" __ expr:Expr __  "}" {
      return expr, nil
    }

// + -
// <= < >= > startsWith IN NOT EMPTY EMPTY
// == !=
// and or
// Lowest to Highest Priority.
// Highest Priority includes the valid primary
// primary contains the Lowest Priority
Expr
  = Logical

LogicalOperators
  = ("or"i / "and"i) {
        return logicalOp(c.text)
      }

Logical
  = head:Equality tail:( __  LogicalOperators __  Equality )* {
      return logicalExpression(head, tail, c.text, c.pos)
    }

EqualityOperators
  = ("==" / "!=" ) {
      return binaryOp(c.text)
    }

Equality
  = head:Relational tail:( __ EqualityOperators __ Relational )* {
      return binaryExpression(head, tail, c.text, c.pos)
    }

RelationalOperators
  = (   "<="
      / "<"
      / ">="
      / ">"
      / "startsWith"i
      / "IN"i
      / "NOT EMPTY"i
      / "EMPTY"i
    ) {
        return binaryOp(c.text)
      }

Relational
  = head:Additive tail:( __ RelationalOperators __ Additive )* {
      return binaryExpression(head, tail, c.text, c.pos)
    }

AdditiveOperator
  = ("+" / "-") {
        return binaryOp(c.text)
      }

Additive
  = head:Multiplicative tail:( __ AdditiveOperator __ Multiplicative )* {
      return binaryExpression(head, tail, c.text, c.pos)
    }

MultiplicativeOperator
  = ("*" / "/") {
      return binaryOp(c.text)
    }

Multiplicative
  = head:Primary tail:( __ MultiplicativeOperator __ Primary )* {
      return binaryExpression(head, tail, c.text, c.pos)
    }

Primary
  = '(' __ expr:Logical __ ')' {
      return expr, nil
    }
  / PrimaryArray
  / StringLiteral
  / RegularExpressionLiteral
  / Duration
  / DateTime
  / Number
  / Field
  / Identifier

PrimaryArray = "[" __ "]" {
    return array(nil, nil, c.text, c.pos), nil
} / "[" __ first:Primary __ rest:PrimaryArrayRest * __ "]" {
    return array(first, rest, c.text, c.pos), nil
}

PrimaryArrayRest =  "," __ element:Primary {
    return element, nil
}

DateFullYear
  = Digit Digit Digit Digit

DateMonth
  // 01-12
  = Digit Digit

DateMDay
  // 01-28, 01-29, 01-30, 01-31 based on
  // month/year
  = Digit Digit

TimeHour
  // 00-23
  = Digit Digit

TimeMinute
  // 00-59
  = Digit Digit

TimeSecond
  // 00-58, 00-59, 00-60 based on leap second
  // rules
  = Digit Digit

TimeSecFrac
  = "." Digit+

TimeNumOffset
  = ("+" / "-") TimeHour ":" TimeMinute

TimeOffset
  = ("Z" / TimeNumOffset)

PartialTime
  = TimeHour ":" TimeMinute ":" TimeSecond TimeSecFrac?

FullDate
  = DateFullYear "-" DateMonth "-" DateMDay

FullTime
  = PartialTime TimeOffset

DateTime
  = FullDate "T" FullTime {
      return datetime(c.text, c.pos)
    }

NanoSecondUnits
  = "ns"

MicroSecondUnits
  = ("us" / "µs" / "μs")

MilliSecondUnits
  = "ms"

SecondUnits
  = "s"

MinuteUnits
  = "m"

HourUnits
  = "h"

DurationUnits
  = (
        NanoSecondUnits
      / MicroSecondUnits
      / MilliSecondUnits
      / SecondUnits
      / MinuteUnits
      / HourUnits
    )

SingleDuration
  = Number DurationUnits

Duration
  = SingleDuration+ {
      return durationLiteral(c.text, c.pos)
    }

StringLiteral
  = ( '"' DoubleStringChar* '"' ) {
        return stringLiteral(c.text, c.pos)
      }
  / ( '"' DoubleStringChar* ( EOL / EOF ) ) {
        return "", errors.New("string literal not terminated")
      }

DoubleStringChar
  = !( '"' / "\\" / EOL ) SourceChar
  / "\\" DoubleStringEscape

DoubleStringEscape
  = '"'
  / ( SourceChar / EOL / EOF ) {
      return nil, errors.New("invalid escape character")
    }

Identifier
  = StringChar+ {
      return identifier(c.text, c.pos)
    }

StringChar
  = !('"'
      / "("
      / ")"
      / ":"
      / "{"
      / "}"
      / ","
      / "$"
      / "."
      / ws
    ) SourceChar

Number
  = Integer '.' Digit+ {
      return numberLiteral(c.text, c.pos)
   }
   / Integer {
      return integerLiteral(c.text, c.pos)
   } 

Integer
  = '0'
  / '-'? NonZeroDigit Digit*

NonZeroDigit
  = [1-9]

Digit
  = [0-9]

Field
  = field:'$' {
      return fieldLiteral(c.text, c.pos)
    }

RegularExpressionLiteral "regular expression"
  = "/" pattern:RegularExpressionBody "/" {
         return pattern, nil
    }

RegularExpressionBody
  = chars:RegularExpressionChar+ {
      return regexLiteral(chars, c.text, c.pos)
  }

RegularExpressionChar
  = ![\\/] re:RegularExpressionNonTerminator {
      return re, nil
  }
  / RegularExpressionBackslashSequence

RegularExpressionBackslashSequence
  = "\\/" {
      return "/", nil
  }
  / "\\" RegularExpressionNonTerminator

RegularExpressionNonTerminator
  = !LineTerminator SourceChar {
      return string(c.text), nil
  }

SourceChar
  = .

__
  = ( ws / EOL )*

ws
  = [ \t\r\n]

LineTerminator
  = [\n\r]

EOL
  = '\n'

EOF
  = !.
