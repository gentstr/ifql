{
package ifql

//go:generate pigeon -o ifql.go ifql.peg
}
// TODO: Change the Literal duration, etc to be a type like this:
/*
type Primary struct {
    Type LiteralType
    Value interface{}
}

*/
Grammar = __ function:Function EOF {
    return function.(*Function), nil
}

Tests =  Function / StringLiteral / Duration / DateTime / Number

Function = name:FunctionName __  "(" __ args:FunctionArgs? __ ")" children:FunctionChain* {
    return NewFunction(name.(string), args, children)
}

FunctionChain = __ "." __ child:Function {
    return child, nil
}

FunctionName = String
FunctionArgs = first:FunctionArg __ rest:FunctionArgsRest* {
    return NewFunctionArgs(first, rest)
}

FunctionArgsRest = "," __  arg:FunctionArg {
    return arg, nil
}

FunctionArg = name:String __  ":" __ arg:FunctionArgValues {
    return &FunctionArg{
        Name: name.(string),
        Arg: arg.(Arg),
    }, nil
}

FunctionArgValues =  WhereExpr / StringLiteral / Regex / Duration / DateTime / Number

WhereExpr = "{" __ expr:Expr __  "}" {
    return &WhereExpr{Expr: expr.(*BinaryExpression)}, nil
}

// + -
// <= < >= > startsWith IN NOT EMPTY EMPTY
// = != 
// and or 
// Lowest to Highest Priority.
// Highest Priority includes the valid primary
// primary contains the Lowest Priority
Expr = Logical

LogicalOperators =  ("or"i / "and"i) { return strings.ToLower(string(c.text)), nil }
Logical = head:Equality tail:( __  LogicalOperators __  Equality )* { return NewBinaryExpression(head, tail) }

EqualityOperators =  ("=" / "!=" ) { return string(c.text), nil }
Equality = head:Relational tail:( __ EqualityOperators __ Relational )* { return NewBinaryExpression(head, tail) }

RelationalOperators =  ( "<=" / "<" / ">=" / ">" / "startsWith"i / "IN"i / "NOT EMPTY"i / "EMPTY"i ) { return strings.ToLower(string(c.text)), nil }
Relational = head:Additive tail:( __ RelationalOperators __ Additive )* { return NewBinaryExpression(head, tail) }

AdditiveOperator = ("+" / "-") { return string(c.text), nil }
Additive = head:Multiplicative tail:( __ AdditiveOperator __ Multiplicative )* { return NewBinaryExpression(head, tail) }

MultiplicativeOperator = ("*" / "/")  { return string(c.text), nil }
Multiplicative = head:Primary tail:( __ MultiplicativeOperator __ Primary )* { return NewBinaryExpression(head, tail) }

Primary = '(' __ expr:Logical __ ')' {
        return expr.(*BinaryExpression), nil
    }
    / StringLiteral / Regex / Duration / DateTime / Number / Field

DateFullYear = Digit Digit Digit Digit

DateMonth
  // 01-12
  = Digit Digit

DateMDay
  // 01-28, 01-29, 01-30, 01-31 based on
  // month/year
  = Digit Digit

TimeHour
  // 00-23
  = Digit Digit

TimeMinute
  // 00-59
  = Digit Digit

TimeSecond
  // 00-58, 00-59, 00-60 based on leap second
  // rules
  = Digit Digit

TimeSecFrac = "." Digit+
TimeNumOffset = ("+" / "-") TimeHour ":" TimeMinute
TimeOffset = ("Z"i / TimeNumOffset)
PartialTime = TimeHour ":" TimeMinute ":" TimeSecond TimeSecFrac?
FullDate = DateFullYear "-" DateMonth "-" DateMDay
FullTime = PartialTime TimeOffset
DateTime = FullDate "T"i FullTime {
    t, err := time.Parse(time.RFC3339Nano, string(c.text))
    if err != nil {
        return nil, err
    }
    return &DateTime{t}, nil
}

NanoSecondUnits = "ns"
MicroSecondUnits = ("us" / "µs" / "μs")
MilliSecondUnits = "ms"
SecondUnits = "s"
MinuteUnits = "m"
HourUnits = "h"
DurationUnits = (NanoSecondUnits / MicroSecondUnits / MilliSecondUnits / SecondUnits / MinuteUnits / HourUnits)

SingleDuration = Number DurationUnits
Duration = SingleDuration+ {
    d, err := time.ParseDuration(string(c.text))
    if err != nil {
        return nil, err
    }
    return &Duration{d}, nil
}

StringLiteral = ( '"' DoubleStringChar* '"' ) {
    s, err := strconv.Unquote(string(c.text))
    if err != nil {
        return nil, err
    }
    return &StringLiteral{s}, nil
} / ( '"' DoubleStringChar* ( EOL / EOF ) ) {
    return "", errors.New("string literal not terminated")
}

DoubleStringChar = !( '"' / "\\" / EOL ) SourceChar / "\\" DoubleStringEscape

DoubleStringEscape =  '"' / ( SourceChar / EOL / EOF ) {
    return nil, errors.New("invalid escape character")
}

String = StringChar+ {
    return string(c.text), nil
}

StringChar = !('"' / "(" / ")" / ":" / "{" / "}" / "," / "$") SourceChar

Number = '-'? Integer ( '.' Digit+ )? {
    n, err := strconv.ParseFloat(string(c.text), 64)
    if err != nil {
        return nil, err
    }
    return &Number{n}, nil
}

Integer = '0' / NonZeroDigit Digit*
NonZeroDigit = [1-9]
Digit = [0-9]

Field = field:'$' {
    return &Field{}, nil
}

Regex = '/' expr:StringLiteral '/' {
    // TODO: perhaps we should not check regex here?
    return NewRegex(expr.(*StringLiteral))
}

SourceChar = .

__ = ( ws / EOL )*
ws = [ \t\r\n]

EOL = '\n'
EOF = !.
