syntax = "proto3";

package api;

service API {
	// Organziations API
	// GetOrganizations returns all organizations. Only an API token from the root organization can make this request.
	rpc GetOrganizations(EmptyAuthRequest) returns (OrganizationCollection) {}

	// GetOrganization returns the information for an organization. Root org or API token with this right can perform.
	rpc GetOrganization(GetOrganizationRequest) returns (Organization) {}

	// CreateOrganization creates the organization, with the initial root user, and an API token for this user with all rights.
	// To call this a validated user with an API token with the create org right must be passed.
	rpc CreateOrganization(CreateOrganizationRequest) returns (Error) {}

	// UpdateOrganization will update the organization's name.
	rpc UpdateOrganization(UpdateOrganizationRequest) returns (Error) {}

	rpc DeleteOrganization(DeleteOrganizationRequest) returns (Error) {}

	// Buckets API
	rpc GetBucketsByOrg(GetBucketsByOrgRequest) returns (BucketCollection) {}

	rpc CreateBucket(CreateBucketRequest) returns (Error) {}

	// UpdateBucket will only allow you to change the retention period.
	rpc UpdateBucket(UpdateBucketRequest) returns (Error) {}

	rpc DeleteBucket(DeleteBucketRequest) returns (Error) {}

	// Users API
	rpc CreateUser(CreateUserRequest) returns (Error) {}
	rpc GetUsersByOrgID(GetUsersByOrgIDRequest) returns (Error) {}
	rpc DeleteUser(DeleteUserRequest) returns (Error) {}

	// API Tokens API
	rpc CreateAPIToken(CreateAPITokenRequest) returns (Error) {}
	rpc UpdateAPIToken(UpdateAPITokenRequest) returns (Error) {}
	rpc DeleteAPIToken(DeleteAPITokenRequest) returns (Error) {}

	// Write API
	rpc Write(WriteRequest) returns (Error) {}

	// Query API
	rpc ValidateQuery(Query) returns (Error) {}
	rpc RunQuery(QueryRequest) returns (stream QueryResponse) {}

	// Background Query API (should throw error if there are no outputs)
	rpc CreateBackgroundQuery(BackgroundQueryRequest) returns (Error) {}
	rpc DeleteBackgroundQuery(BackgroundQueryRequest) returns (Error) {}
	rpc GetBackgroundQueries(Organization) returns (BackGroundQueriesResponse) {}
	rpc GetBackgroundQueryStatus(BackgroundQueryRequest) returns (BackgroundQueryStatusResponse) {}

	rpc GetSecretsByOrgID(EmptyAuthRequest) returns (SecretCollection) {}

	// Registry API (enterprise)
	rpc RegisterPackage(RegisterPackageRequest) returns (Error) {}
	rpc DeletePackage(DeletePackageRequest) returns (Error) {}
	rpc GetPackage(GetPackageRequest) returns (Package) {}
	rpc GetPackagesByOrgID(GetPackagesByOrgIDRequest) returns (GetPackagesResponse) {}

	// Rate limiting API (enterprise)

	// ************
	// IMPORT/EXPORT functionality
	// Bulk Write API (should take already compressed tsm files or something like that)
	// Bulk Read API (should return tsm files or something like that)
	// Scheduled Replication
	// periodically connect to remote source, perform bulk read and write locally
	// preiodically perform bulk read against self, then bulk write to remote
	// need to have a method for import/export of orgs, users, tokens, and other API data

	// *******************************************
	// Chonograf API
	// Dashboards API

	// Config options

	// Annotations

	// Alert Rules

	// Alerts

	// Notification Rules

	// Notifications (just another time series that marks when a notification was sent to where)

	// Input Endpoints (or scrape targets)

	// Output Endpoints (could be notification places or other message/database systems)

	// *******************************************
	// Telegraf API

	// Input configs (for local proc stuff, otherwise should use Input Endpoints)

	// Output configs (this is similar to Output Endpoints, we need to combine these)
}

// EmptyAuthRequest is used for any request that takes only authentication and authorizaiton arguments
message EmptyAuthRequest {
	uint32 organization_id = 1;
	APIToken api_token = 2;
}

message Error {
	enum Kind {
		UNKNOWN = 1;
	}
	Kind kind = 1;
	string message = 2;
}

message OrganizationCollection {
	repeated Organization organizations = 2;
}

message Organization {
	uint32 id = 1;
	bool is_root_organization = 1;
	string name = 2;
	User root_user = 3;
	APIToken api_token = 4;
	repeated Bucket buckets = 5;
	repeated Limits limits = 6;
	repeated User users = 7;
}

message CreateOrganizationRequest {
	string name = 1;
	APIToken api_token = 2;
}

message UpdateOrganizationRequest {
	uint32 id = 1;
	string name = 2;
	APIToken api_token = 3;
}

// GetOrganizationRequest will return the org specified by either its ID or name
message GetOrganziationRequest {
	uint32 organization_id = 1;
	string organization_name = 2;
	APIToken api_token = 3;
}

message Bucket {
	uint32 id = 1;
	string name = 2;
	Limits limits = 3;
	string retention_period = 4;
	repeated RetentionRule retention_rules = 5;
	AuthorizationScope default_scope = 6;
	repeated ETLRule etl_rules = 7;
	enum Kind {
		PERSISTENT = 1;
		CIRCULAR = 2;
		STREAM = 3;
	}
}

message CreateBucketRequest {
	uint32 organization_id = 1;
	string name = 2;
	string retention_duration = 3;
}

message User {
	uint32 id = 1;
	repeated APIToken api_tokens = 2;
	repeated Organization organizations = 3;

	// what stuff for oauth?
}

message CreateUserRequest {
	// organizations that the user should be added to on creation
	repeated uint32 organization_ids = 1;
	APIToken api_token = 2;
	User user = 3;
}

// APItoken must be passed for every request to the API to authenticate and authorize the request
message APIToken {
	string key = 1;
	// how should API keys work?
	string secret = 2;
	string description = 3;
	repeated AuthorizationScope authorization_scopes = 4;
}

message CreateAPITokenRequest {
	uint32 user_id = 1;

	// api_token is the token to be authenticated and authorized to make this request
	APIToken api_token = 2;

	// name is the human readable name of the token. It must be unique within a user
	string name = 3;
}

message AuthorizationScope {
	enum Resource {
		BUCKET = 0;
		ORGANIZATION = 1;
	}
	enum Right {
		CREATE = 1;
		UPDATE = 2;
		DELETE = 3;
		READ = 4;
		WRITE = 5;
	}
	Resource resource = 1;
	repeated Right rights = 2;
}

message Query {
	string script = 1;
}

message QueryRequest {
	enum ResponseType {
		JSON_LINES = 1;
		ARROW = 2;
		CSV = 3;
	}

	Query query = 1;
	ResponseType response_type = 2;
}

message QueryResponse {
	oneof Kind {
		JSONLinesResponse json = 1;
		ArrowResponse arrow = 2;
		CSVResponse csv = 3;
	}
}

message JSONLinesResponse {
	// TODO
}

message ArrowResponse {
	// TODO
}

message CSVResponse {
	// TODO
}

message WriteRequest {
	APIToken api_token = 1;
	repeated string lines = 2;
	repeated Point points = 3;
}

message Point {
	repeated Tag tags = 1;
	int64 timestamp = 2;
	oneof valuetype {
		Float64 float64 = 2;
		String string = 3;
		Int64 int64 = 4;
		Uint64 uint64 = 5;
		Bool bool = 6;
	}
}

message Tag {
	string key = 1;
	string value = 2;
}

// Limits represents rate, storage and other
// limits.
// limit number of concurrent writes/queries rather than per/min/sec?
message Limits {
	int64 write_bytes_min = 1;
	int64 read_bytes_min = 2;
	int64 storage_mb = 3;
	int write_requests_min = 4;
	int read_requests_min = 5;
	int batch_tasks = 6;
	int stream_tasks = 7;
	int users = 8;
	int buckets = 9;
	int scrape_targets = 10;
}

// RetentionRule 
message RetentionRule {
	string matcher = 1;
	string duration = 2;
}

message BackgroundQueryRequest {
	uint32 organization_id = 1;
	BackgroundQuery query = 2;
}

message BackgroundQuery {
	string name = 1;
	Query query = 2;
	Organization organization = 3;
}

message BackgroundQueryStatusResponse {
	repeated BackgroundQueryRun runs = 1;
}

message BackgroundQueryRun {
	int64 timestamp = 1;
	string message = 2;
	Error error = 3;
}

message QueryQuota {
	int32 priority = 2;
	int concurrency_quota = 3;
	int64 memory_bytes_quota = 4;
}

// TODO: nathaniel to fill this out
message QuerySpec {

}

/*
    Managing secrets
*/

message Secret {
	string name = 1;
	string message = 2;
}

message SecretCollection {
	repeated Secret secrets = 1;
}

message DiscoveryService {
	oneof Kind {
		EC2Discovery ec2 = 1;
		K8SDiscovery k8s = 2;
		// TODO: fill out the rest and create discovery service messages
	}

	string name = 1;
	int32 refresh_interval_seconds = 2;
	bool enabled = 3;
}

message EC2Discovery {

}

message K8SDiscovery {

}

message ScrapeTarget {
	oneof Kind {
		PrometheusTarget prometheus = 1;

		// Telegraf plugins
		SystemTarget system = 2;
		RedisTarget redis = 3;
		// TODO: fill out rest
	}
	string name = 1;
	string discover_service = 2;
	bool enabled = 3;
	int32 scrape_interval_seconds = 4;
	int32 scrape_timeout_seconds = 5;
	repeated Bucket output_buckets = 6;

	// TODO: what other Telegraf agent config options are relevant here?
}

message PrometheusTarget {
	uint16 port = 1;
	string path = 2;
	string host = 3;
}

/*
  Package Registry messages
*/
message Package {
	string organizationName = 1;
	string namespace = 2;
	string script = 3;
	string version = 4;
}

message GetPackagesResponse {
	repeated Package packages = 1;
	Error error = 2;
}

/*
    Telegraf configs
*/

/*
    Chronograf configs
*/