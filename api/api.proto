syntax = "proto3";

package api;

service API {
	// only these two functions don't require a token
	rpc GetTokenByUser(string, string) returns(Token) {}
	rpc GetTokenByApiKey(string, string)

	// every function should have a token (for authorization)
	// TODO: how to do authentication/authorization in gRPC?
	rpc GetOrganizations() returns (OrganizationCollection) {}
	rpc GetOrganization(uint32 id) returns (Organization) {}

	// Write API

	// Query API
	rpc ValidateQuery(Query) returns (Error) {}
	rpc RunQuery(QueryRequest) returns (stream QueryResponse) {}

	// Background Query API (should throw error if there are no outputs)
	rpc CreateBackgroundQuery(BackgroundQueryRequest) returns (Error) {}
	rpc DeleteBackgroundQuery(BackgroundQueryRequest) returns (Error) {}
	rpc GetBackgroundQueries(Organization) returns (BackGroundQueriesResponse) {}
	rpc GetBackgroundQueryStatus(BackgroundQueryRequest) returns (BackgroundQueryStatusResponse) {}

	// TODO 
	rpc TestK8sConfig(K8sConfig) returns (Error) {}

	rpc AddFunction(string, Query) returns (Error) {}
	rpc DeleteFunction(string) returns (Error) {}

	rpc GetSecretsByOrgID(uint32) returns (SecretCollection) {}

	// Registry API (enterprise)
	rpc RegisterPackage(Package) returns (Error) {}
	rpc DeletePackage(Package) returns (Error) {}
	rpc GetPackage(org, namespace) returns (Package) {}
	rpc GetPackages(Organization) returns (GetPackagesResponse) {}
}

message GetPackagesResponse {
	repeated Package packages = 1;
	Error error = 2;
}

message QueryRequest {
	enum ResponseType {
		JSON_LINES = 1;
		ARROW = 2;
		CSV = 3;
	}

	Query query = 1;
}

message QueryResponse {
	oneof Kind {
		JSONLinesResponse json = 1;
		ArrowResponse arrow = 2;
		CSVResponse csv = 3;
	}
}

message JSONLinesResponse {
	// TODO
}

message ArrowResponse {
	// TODO
}

message CSVResponse {
	// TODO
}

message Package {
	string organizationName = 1;
	string namespace = 2;
	string script = 3;
	string version = 4;
}

message UserAuth {
	string name = 1;
	string password = 2;
}

message Error {
	enum Kind {
		UNKNOWN = 1;
	}
	Kind kind = 1;
	string message = 2;
}

message OrganizationCollection {
	repeated Organization organizations = 1;
}

message Organization {
	uint32 id = 1;
	string name = 2;
	Bucket buckets = 3;
	Limits limits = 4;
	User users = 5;
}

message Bucket {
	uint32 id = 1;
	string name = 2;
	Limits limits = 3;
	string retention_period = 4;
	repeated RetentionRule retention_rules = 5;
	AuthorizationScope default_scope = 6;
	repeated ETLRule etl_rules = 7;
	enum Kind {
		PERSISTENT = 1;
		CIRCULAR = 2;
		STREAM = 3;
	}
}

message User {
	uint32 id = 1;
	repeated ApiKey keys = 2;
	repeated Organization organizations = 3;

	// what stuff for oauth?
}

message ApiKey {
	string key = 1;
	// how should API keys work?
	string secret = 2;
	string description = 3;
	repeated AuthorizationScope authorization_scopes = 4;
}

message AuthorizationScope {
	enum Resource {
		BUCKET = 0;
		ORGANIZATION = 1;
	}
	enum Right {
		CREATE = 1;
		UPDATE = 2;
		DELETE = 3;
		READ = 4;
		WRITE = 5;
	}
	Resource resource = 1;
	repeated Right rights = 2;
}

// Limits represents rate, storage and other
// limits.
// limit number of concurrent writes/queries rather than per/min/sec?
message Limits {
	int64 write_bytes_min = 1;
	int64 read_bytes_min = 2;
	int64 storage_mb = 3;
	int write_requests_min = 4;
	int read_requests_min = 5;
	int batch_tasks = 6;
	int stream_tasks = 7;
	int users = 8;
	int buckets = 9;
	int scrape_targets = 10;
}

// RetentionRule 
message RetentionRule {
	string matcher = 1;
	string duration = 2;
}

message Query {
	string script = 1;
}

message BackgroundQueryRequest {
	uint32 organization_id = 1;
	BackgroundQuery query = 2;
}

message BackgroundQuery {
	string name = 1;
	Query query = 2;
	Organization organization = 3;
}

message BackgroundQueryStatusResponse {
	repeated BackgroundQueryRun runs = 1;
}

message BackgroundQueryRun {
	int64 timestamp = 1;
	string message = 2;
	Error error = 3;
}

message QueryQuota {
	int32 priority = 2;
	int concurrency_quota = 3;
	int64 memory_bytes_quota = 4;
}

// TODO: nathaniel to fill this out
message QuerySpec {

}

/*
    Managing secrets
*/

message Secret {
	string name = 1;
	string message = 2;
}

message SecretCollection {
	repeated Secret secrets = 1;
}

message DiscoveryService {
	oneof Kind {
		EC2Discovery ec2 = 1;
		K8SDiscovery k8s = 2;
		// TODO: fill out the rest and create discovery service messages
	}

	string name = 1;
	int32 refresh_interval_seconds = 2;
	bool enabled = 3;
}

message EC2Discovery {

}

message K8SDiscovery {

}

message ScrapeTarget {
	oneof Kind {
		PrometheusTarget prometheus = 1;

		// Telegraf plugins
		SystemTarget system = 2;
		RedisTarget redis = 3;
		// TODO: fill out rest
	}
	string name = 1;
	string discover_service = 2;
	bool enabled = 3;
	int32 scrape_interval_seconds = 4;
	int32 scrape_timeout_seconds = 5;
	repeated Bucket output_buckets = 6;

	// TODO: what other Telegraf agent config options are relevant here?
}

message PrometheusTarget {
	uint16 port = 1;
	string path = 2;
	string host = 3;
}


/*
    Telegraf configs
*/

/*
    Chronograf configs
*/