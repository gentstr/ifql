syntax = "proto3";

package api;

service API {
	rpc GetOrganizations() returns (Organizations) {}
	rpc GetOrganization(uint32 id) returns (Organization) {}

	// TODO add tests for all kapacitor notifier configs
	rpc TestSlackConfig(SlackConfig, SlackNotifier, string) returns (Error) {}

	// TODO 
	rpc TestK8sConfig(K8sConfig) returns (Error) {}
}

message Error {
	enum Kind {
		UNKNOWN = 1;
	}
	Kind kind = 1;
	string message = 2;
}

message Organizations {
	repeated Organization
}

message Organization {
	uint32 id = 1;
	string name = 2;
	Bucket buckets = 3;
	Limits limits = 4;
	User users = 5;
	repeated SlackConfig slack_configs = 6;
}

message Bucket {
	uint32 id = 1;
	string name = 2;
	Limits limits = 3;
	string retention_period = 4;
	repeated RetentionRule retention_rules = 5;
	AuthorizationScope default_scope = 6;
	repeated ETLRule etl_rules = 7;
}

message User {
	uint32 id = 1;
	repeated ApiKey keys = 2;
	repeated Organization organizations = 3;

	// what stuff for oauth?
}

message ApiKey {
	string key = 1;
	// how should API keys work?
	string secret = 2;
	string description = 3;
	repeated AuthorizationScope authorization_scopes = 4;
}

message AuthorizationScope {
	enum Resource {
		BUCKET = 0;
		ORGANIZATION = 1;
	}
	enum Right {
		CREATE = 1;
		UPDATE = 2;
		DELETE = 3;
		READ = 4;
		WRITE = 5;
	}
	Resource resource = 1;
	repeated Right rights = 2;
}

// Limits represents rate, storage and other
// limits.
// limit number of concurrent writes/queries rather than per/min/sec?
message Limits {
	int64 write_bytes_min = 1;
	int64 read_bytes_min = 2;
	int64 storage_mb = 3;
	int write_requests_min = 4;
	int read_requests_min = 5;
	int batch_tasks = 6;
	int stream_tasks = 7;
	int users = 8;
	int buckets = 9;
	int scrape_targets = 10;
}

// RetentionRule 
message RetentionRule {
	string matcher = 1;
	string duration = 2;
}

message ETLRule {
	Query query = 1;
	repeated Bucket input_buckets = 2;
	Bucket output_bucket = 3;
}

message Query {
	string query = 1;
	int32 priority = 2;
	int concurrency_quota = 3;
	int64 memory_bytes_quota = 4;
}

/* Alert Handling */
message AlertHandler {
	string name = 1;
	uint32 bucket_id = 2;

	// log_bucket_id is where the log that a notification was
	//               sent will be written.
	uint32 log_bucket_id = 3;
	repeated NotificationTarget notification_targets = 4;

	// rate limits. Will limit how many times notifications
	//              get sent to the targets in this handler
	uint32 max_count = 5;
	uint32 duration = 6;
}

message NotificationTarget {
	oneof kind {
		SlackNotifier slack_notifier = 1;
		EmailNotifier email_notifier = 2;
		// TODO finish the notifiers
	}
}

message SlackNotifier {
	string name = 1;
	string username = 2;
	string channel = 3;
	string icon_emoji = 4;
}

message EmailNotifier {
	string name = 1;
	string from = 2;
	repeated string to = 3;
}

/*
  Service Configs

  ** Only service configs can contain secrets
*/

/*
    Kapacitor configs
*/

message SlackConfig {
	string name = 1;
	bool enabled = 2;
}

/*
    Telegraf configs
*/

/*
    Chronograf configs
*/