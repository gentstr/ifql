// potential builtins
projectField = (f, table=<-) => filter(table:table, fn: (r) => r._field == f)
projectMeasurement = (m, table=<-) => filter(table:table, fn: (r) => r._measurement == m)
select = (measurement, field, table=<-) => projectMeasurement(m:measurement, table:table) |> projectField(f:field)
withTag = (value, table=<-) => filter(table:table, fn: (r) => r["cluster_id"] == value)



// I don't need these for this set of queries, but I think they would be nice to have
// also they would need to write a custom func in Go
// AnyOf = (table=<-, functions) =>  // filter that returns true if any of the list of input functions is true
// OneOf = (table=<-, functions) => // filter that returns true if exactly one of the input functions is true
// AllOf = (table=<-, functions) => // conjunction of filter functions.

// helper functions //
hostFilter = (table=<-) => filter(table:table, fn: (r) => (r["host"] == "influxmon"))
// could be a built-in but we don't want to get too carried away with compound functions
fromRange = (forDB, forRange) => from(db:forDB) |> range(start:forRange)

// InfluxQL Disk Usage Query
// SELECT last("used")/1073741824 AS "used" FROM
//   "telegraf"."default"."disk"
//   WHERE time > :dashboardTime:
//     AND cluster_id = :Cluster_Id:
//     AND (host =~ /.data./ OR host =~ /tot-.*-(3|4)/)
//   FILL(0)

//     // fill seems to be used to return a default value. Not sure how IFQL behaves

DiskUsage = (DASHTIME) =>
    fromRange(forDB:"telegraf", forRange:DASHTIME)
      |> select(measurement: "disk", field: "used")
      //|> withTag(key: "cluster_id", value: CID)
      //|> hostfilter()
      |> last()
      |> map(fn:(r) => r._value / 1073741824)

DiskAllocated = (DASHTIME, INTERVAL) =>
  DiskUsage(DASHTIME:DASHTIME)
    |> window(every:INTERVAL)
    |> last()


DiskAllocated(DASHTIME: -200h, INTERVAL: 10s)