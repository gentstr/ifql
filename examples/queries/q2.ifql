// potential builtins
projectField = (f, table=<-) => filter(table:table, fn: (r) => r._field == f)
projectMeasurement = (m, table=<-) => filter(table:table, fn: (r) => r._measurement == m)
select = (measurement, field, table=<-) => projectMeasurement(m:measurement, table:table) |> projectField(f:field)
withTag = (value, table=<-) => filter(table:table, fn: (r) => r["cluster_id"] == value)



// I don't need these for this set of queries, but I think they would be nice to have
// also they would need to write a custom func in Go
// AnyOf = (table=<-, functions) =>  // filter that returns true if any of the list of input functions is true
// OneOf = (table=<-, functions) => // filter that returns true if exactly one of the input functions is true
// AllOf = (table=<-, functions) => // conjunction of filter functions.

// helper functions //
hostFilter = (table=<-) => filter(table:table, fn: (r) => (r["host"] == "influxmon"))
// could be a built-in but we don't want to get too carried away with compound functions
fromRange = (forDB, forRange) => from(db:forDB) |> range(start:forRange)

// InfluxQL Memory Per Data Node Query:
// SELECT last("max") from
//   (SELECT max("total")/1073741824 FROM
//     "telegraf"."default"."mem"
//     WHERE "cluster_id" = :Cluster_Id:
//      AND time > :dashboardTime:
//      AND (host =~ /.*data.*/ OR host =~ /tot-.*-(3|4)/)
//      GROUP BY :interval:, host)

MemPerDataNode = (DASHTIME, INTERVAL) =>
    fromRange(forDB:"telegraf", forRange:DASHTIME)
      |> select(measurement: "mem", field: "total")
      //|> withTag(key: "cluster_id", value: CID)
      //|> hostfilter()
      |> window(every: INTERVAL)
      |> group(by: ["host"])
      |> max()
      |> map(fn:(r) => r._value / 1073741824)

MemPerDataNode(DASHTIME: -300h, INTERVAL: 30m)