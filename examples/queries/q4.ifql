// potential builtins
projectField = (f, table=<-) => filter(table:table, fn: (r) => r._field == f)
projectMeasurement = (m, table=<-) => filter(table:table, fn: (r) => r._measurement == m)
select = (measurement, field, table=<-) => projectMeasurement(m:measurement, table:table) |> projectField(f:field)
withTag = (value, table=<-) => filter(table:table, fn: (r) => r["cluster_id"] == value)



// I don't need these for this set of queries, but I think they would be nice to have
// also they would need to write a custom func in Go
// AnyOf = (table=<-, functions) =>  // filter that returns true if any of the list of input functions is true
// OneOf = (table=<-, functions) => // filter that returns true if exactly one of the input functions is true
// AllOf = (table=<-, functions) => // conjunction of filter functions.

// helper functions //
hostFilter = (table=<-) => filter(table:table, fn: (r) => (r["host"] == "influxmon"))
// could be a built-in but we don't want to get too carried away with compound functions
fromRange = (forDB, forRange) => from(db:forDB) |> range(start:forRange)

// InfluxQL Disk Usage Query
// SELECT last("used")/1073741824 AS "used" FROM
//   "telegraf"."default"."disk"
//   WHERE time > :dashboardTime:
//     AND cluster_id = :Cluster_Id:
//     AND (host =~ /.data./ OR host =~ /tot-.*-(3|4)/)
//   FILL(0)

//     // fill seems to be used to return a default value. Not sure how IFQL behaves

//  InfluxQL Percent Availability Query
// SELECT (sum("service_up") / count("service_up"))*100 AS "up_time"
//   FROM "watcher"."autogen"."ping"
//   WHERE cluster_id = :Cluster_Id:
//     AND time > :dashboardTime:
//   FILL(0)


PercentAvailability = (DASHTIME) => {
  serviceUp = (fromRange(forDB:"watcher", forRange: DASHTIME)
      |> select(measurement: "ping", field: "service_up"))
      //|> withTag(key: "cluster_id", value: CID)

  up_time = sum(serviceUp) / count(serviceUp) * 100
  return up_time
}
PercentAvailability(DASHTIME:-1000h)